---
title: "1 Binding site definition and characterisation"
author: "Melina"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  BiocStyle::html_document:
    toc_float: TRUE
    toc: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, results = TRUE)
```

# What was done?

- The gencode annotation retrieved as gtf file is filtered for standard chromosomes. Transcripts with transcript support level <=3 or NA are only kept if no other transcript of the same gene with a higher levels exists.
- PURA binding sites are defined from the PURA iCLIP experiments with endogenous PURA expression in HeLa cells. 
- Reproducibility of binding sites between samples


# Glossary

- crosslink site: nucleotide that has been found crosslinked to PURA once or several times
- crosslink events: crosslink events detected (one crosslink site can contain several crosslink events)
- pureclip site: nucleotide bound, as calculated from PureCLIP 
- binding site: PURA binding site (5nt wide) as defined in the binding site definition below

```{r}
library(GenomicRanges)
library(rtracklayer)
library(knitr)
library(GenomicFeatures)
library(dplyr)
library(ggpubr)
library(Gviz)
library(biomaRt)

report_color <- (pals::ocean.solar(15))
source("/Users/melinaklostermann/Documents/projects/PURA/02_R_new_pip/XX-helpful-chunks/theme_paper.R")
```

```{r}
################################################################################
###                       CODE REVIEW SUMMARY                                ###
################################################################################
### 
### Review by:          Mirko BrÃ¼ggemann
### Comment shortcut:   MB
### Date:               10.08.2022
### Time spent:         ~3h

# Main objective: 
# Define binding sites from PureCLIP crosslink positions
# 
# Input:
# - PureCLIP sites as .bed
# - iCLIP signal as .bw for each replicate (1-4)
# - iCLIP signal as .bw as a merge of all replicates 
# - gene annotation as of gencode v31 as GFF3
# 
# Minor tasks the script performs are: 
# - Filtering of gene annotation
# 
# Major/ issues:
# - No major issues or bugs. The script works as it is and produces correct results.
#   It is well structured and code logic can be followed easily 
#
# Minor/ suggestions:
# - The script deals with the gencode annotation filtering with is never used and 
# unnecessary (-> could be moved to its own script)
# - .bw files are imported several times over again in different formats (RLE and
#   GRanges). 
# - The GRanges imports are never used, so they could be removed
# - The RLE imports happen on various levels (at the begining of the script,
#   within functions, at the end of the script).
# - The same iCLIP signal is also imported twice, as merge and as replicates
# - Binding site post-processing and filtering assumes a width of 5nt which is 
#   hard coded several times, which makes testing error prone
# - Binding site post-processing and filtering has small logical inconsitencies
#   in the way filtering steps act upon each other
#
#
# Nice job! 
# Feel free to review the review :) 
#
```


# Input

```{r echo=TRUE}
# bigwig files of crosslink events (all 4 samples merged)

bw_all_plus_path <-
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/merged/bw/imb_koenig_2020_07_PURAendo.v2uniqMD.duprm.plus.bw"
bw_all_minus_path <-
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/merged/bw/imb_koenig_2020_07_PURAendo.v2uniqMD.duprm.minus.bw"

# bigwig files of crosslink events (all 4 samples separate)
# single samples

bw_1_plus_path <-
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/bw/all/DR/imb_koenig_2020_07_PURAendo_1.v2uniqMD.duprm.plus.bw"
bw_1_minus_path <- 
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/bw/all/DR/imb_koenig_2020_07_PURAendo_1.v2uniqMD.duprm.minus.bw"

bw_2_plus_path <-
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/bw/all/DR/imb_koenig_2020_07_PURAendo_2.v2uniqMD.duprm.plus.bw"
bw_2_minus_path  <- 
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/bw/all/DR/imb_koenig_2020_07_PURAendo_2.v2uniqMD.duprm.minus.bw"

bw_3_plus_path  <-
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/bw/all/DR/imb_koenig_2020_07_PURAendo_3.v2uniqMD.duprm.plus.bw"
bw_3_minus_path <-
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/bw/all/DR/imb_koenig_2020_07_PURAendo_3.v2uniqMD.duprm.minus.bw"

bw_4_plus_path <-
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/bw/all/DR/imb_koenig_2020_07_PURAendo_7.v2uniqMD.duprm.plus.bw"
bw_4_minus_path <-
  "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/imb_koenig_2020_07_koenig_iCLIP_PURA_endogene/bw/all/DR/imb_koenig_2020_07_PURAendo_7.v2uniqMD.duprm.minus.bw"

# import rles
# get bw's as rles
sample1.minus.rle <- import.bw( bw_1_minus_path, as="Rle") %>% keepStandardChromosomes(pruning.mode = "coarse")
sample2.minus.rle <- import.bw( bw_2_minus_path, as="Rle") %>% keepStandardChromosomes(pruning.mode = "coarse")
sample3.minus.rle <- import.bw( bw_3_minus_path, as="Rle") %>% keepStandardChromosomes(pruning.mode = "coarse")
sample4.minus.rle <- import.bw( bw_4_minus_path, as="Rle") %>% keepStandardChromosomes(pruning.mode = "coarse")

sample1.plus.rle <- import.bw( bw_1_plus_path, as="Rle") %>% keepStandardChromosomes(pruning.mode = "coarse")
sample2.plus.rle <- import.bw( bw_2_plus_path, as="Rle") %>% keepStandardChromosomes(pruning.mode = "coarse")
sample3.plus.rle <- import.bw( bw_3_plus_path, as="Rle") %>% keepStandardChromosomes(pruning.mode = "coarse")
sample4.plus.rle <- import.bw( bw_4_plus_path, as="Rle") %>% keepStandardChromosomes(pruning.mode = "coarse")

bw_plus_rle <- import.bw(bw_all_plus_path, as="Rle")
bw_minus_rle <- import.bw(bw_all_minus_path, as="Rle")



# PureCLIP calls (obtained by running PureCLIP on pseudo-samples 1u2 and 3u4 see below)

pureclip_path <- "/Users/melinaklostermann/Documents/projects/PURA/01_raw_data/PURA_endo/PureCLIP/peakcalling_pura_endo_sites.bed"

# gene annotation (gencode annotation v31)

mygft <-"/Users/melinaklostermann/Documents/projects/anno/GENCODEv31-p12/gencode.v31.annotation.gff3"

# size of BS 
wbs <- 5

```

# Preprocess input files

```{r}


### TODO MB
### 1)
### The split_bw_crosslinks_to_1_nt function splits the GRanges from the bigwigs into 1nt chunks, since they are not per default
### an other way would be to import the bigwigs as RLE and then turn the RLE into a GRanges instead.
### NOTE GRanges(sample1.plus.rle) does not split it up into 1nt size, how do you mean?

### 2)
### bw_all_samples and bw_merges are constructed but never used in the script. They are just exported at the end.
### If they are used by some other script, why not constructing the objects there?
### NOTE I use them in several chases later, an only want to do this step once in the beginning, moved also to script 0 now
### Also both are unnamed list which can only be accessed by using [], maybe turn them into named lists instead
### eg bw_merges$bw_all_plus would be a nicer way
### NOTE MK yes you are right, but I do not want to change it in all scripts now



########################################
# Load and filter Gencode annotation
#######################################

### TODO MB
### could be sourced out to a seperate script to improve reproducibility since
### all analysis for the entire project should be based on the same annotation.
### You clould have one script that filters the annoation and stores it. All 
### other scripts could then just load the filtered annotation as TxDB or GRanges.
### Also the filtered annotation is never used in this script. So there is no need to 
### import or process it here
### CHANGED this was the script, were I store it an then always import it afterwards, but I moved it to script 0 now



########################
# Get PureCLIP output
#########################
pureclip_sites <- import(pureclip_path, format = "bedgraph") %>% 
  keepStandardChromosomes(., pruning.mode = "coarse")

# clean up columns
pureclip_sites <- as.data.frame(pureclip_sites) %>% makeGRangesFromDataFrame(keep.extra.columns = T)
pureclip_sites$NA.2 <- NULL
pureclip_sites$score <- pureclip_sites$NA.
pureclip_sites$NA. <- NULL
strand(pureclip_sites) <- pureclip_sites$NA.1
pureclip_sites$NA.1 <- NULL
pureclip_sites$round_score <- round(pureclip_sites$score, digits = 1)

pureclip_sites <- keepStandardChromosomes(pureclip_sites, pruning.mode = "coarse")

```

# Definition of binding sites

Note: Adapted from Busch et al. 2019 - "iCLIP data analysis: A complete pipeline from sequencing reads to RBP binding sites"

```{r}
############################
# Make 5-nt binding sites
###########################
Define_Binding_Sites <- function(pureclip, bw_plus, bw_minus, windowsize, out){
  
  # merge gaps < 8 from single PureCLIP sites
  pureclip = GenomicRanges::reduce(pureclip, min.gapwidth = 8)
  
  # remove sites with 1 or 2 nt length
  pureclip = pureclip[width(pureclip) > 2]
  
  ### TODO MB
  ### here where you actually use the bigwig signal you re-import it 
  ### as RLE. It is also maybe not the best idea to have the RLE import hidden 
  ### in a function. 
  ### It is a bit confusing that your script imports the same information in 4
  ### different formats at various times in the script (GRanges, RLE + Replicate, Merge)
  ### 
  
  
  
  bw_plus = import.bw(bw_plus, as="Rle")
  bw_minus = import.bw(bw_minus, as= "Rle")
  
  
  final.peaks.plus.gr <- GRanges()
  final.peaks.minus.gr <- GRanges()
  
  
  # initialize the remaining PureCLIP CL regions to check for peaks
  remaining.regions.plus.gr <- subset(pureclip, strand == "+")
  remaining.regions.minus.gr <- subset(pureclip, strand == "-")
  
  window.radius <- (windowsize-1)/2
  while(TRUE){
    
    # no regions left to check for peaks
    if (length(remaining.regions.plus.gr) == 0 & length(remaining.regions.minus.gr) == 0){
      break
    }
    
    if (length(remaining.regions.plus.gr) != 0 ){
      # get the raw CL counts in the remaining PureCLIP CL regions
      # returns rle list of all regions and turns it into matrix
      raw.remaining.PureCLIP.CL.regions.plus.m <- as.matrix(bw_plus[remaining.regions.plus.gr])
      
      # identify the center of the PureCLIP CL regions (position with max counts)
      # and store its index
      raw.remaining.PureCLIP.CL.regions.plus.m[
        is.na(raw.remaining.PureCLIP.CL.regions.plus.m)] <- -Inf # set Na to -infinite
      max.pos.indice.plus <- max.col(raw.remaining.PureCLIP.CL.regions.plus.m, 
                                     ties.method = "first")
      
      
      # create a peak region of 9 nt that is centered to the max position
      peaks.plus.gr <- remaining.regions.plus.gr
      start(peaks.plus.gr) <- start(peaks.plus.gr) + max.pos.indice.plus - 1
      end(peaks.plus.gr) <- start(peaks.plus.gr)
      peaks.plus.gr <- peaks.plus.gr + window.radius
      
      
      # store the new peaks
      final.peaks.plus.gr <- c(final.peaks.plus.gr, peaks.plus.gr)
      
      # remove the peaks from the CL regions to search for additional peaks
      # excise additionally 4 nucleotides up and downstream
      peaks.plus.grl <- as(peaks.plus.gr+window.radius, "GRangesList")
      
      remaining.regions.plus.gr <- unlist(psetdiff(remaining.regions.plus.gr, peaks.plus.grl))
    }
    if (length(remaining.regions.minus.gr) != 0 ){
      # get the raw CL counts in the remaining PureCLIP CL regions
      # returns rle list of all regions and turns it into matrix
      raw.remaining.PureCLIP.CL.regions.minus.m <- as.matrix(
        bw_minus[remaining.regions.minus.gr])
      
      # identify the center of the PureCLIP CL regions (position with max counts) 
      # and store its indice
      raw.remaining.PureCLIP.CL.regions.minus.m[
        is.na(raw.remaining.PureCLIP.CL.regions.minus.m)] <- -Inf
      max.pos.indice.minus <- max.col(raw.remaining.PureCLIP.CL.regions.minus.m, ties.method = "last")
      
      # create a peak region of 9nt that is centered to the max position
      peaks.minus.gr <- remaining.regions.minus.gr
      start(peaks.minus.gr) <- start(peaks.minus.gr) + max.pos.indice.minus - 1
      end(peaks.minus.gr) <- start(peaks.minus.gr)
      peaks.minus.gr <- peaks.minus.gr + window.radius
      
      # store the new peaks
      final.peaks.minus.gr <- c(final.peaks.minus.gr, peaks.minus.gr)
      
      # remove the peaks from the CL regions to search for additional peaks
      # excise additionally 4 nucleotides up and downstream
      peaks.minus.grl <- as(peaks.minus.gr+window.radius, "GRangesList")
      
      remaining.regions.minus.gr <- unlist(psetdiff(remaining.regions.minus.gr,
                                                    peaks.minus.grl))
    }
  }

  binding_sites <- c(final.peaks.plus.gr, final.peaks.minus.gr)
  return(binding_sites)
}


binding_sites <- Define_Binding_Sites(pureclip = pureclip_sites, 
                                      bw_plus = bw_all_plus_path, 
                                      bw_minus = bw_all_minus_path,
                                      windowsize = wbs, # windowsize - size that binding sites should have 
                                      out =  "./Binding_site_windows_5nt" )



############################
# Keep only BS with PureCLIP center
############################

# get centers
### TODO MB
### be aware that this is hard coded for a binding site width of 5
### CHANGED MK

# add score from center PureCLIP sites as binding site score

BS_centers <- binding_sites - ((wbs-1)/2)

	
# keep only overlaps with PureCLIP sites
pureclip_sites <- makeGRangesFromDataFrame(pureclip_sites,  keep.extra.columns = TRUE)

binding_sites_center_PS <- binding_sites[queryHits(findOverlaps(
 BS_centers, pureclip_sites))]

binding_sites_center_PS$score <- pureclip_sites[subjectHits(findOverlaps(
  BS_centers, pureclip_sites))]$score

binding_sites_center_PS$score <- pureclip_sites[subjectHits(findOverlaps(
  BS_centers, pureclip_sites, ignore.strand = F))]$score


### TODO MB
### since you reduced the binding sites to only those that have a PureCLIP site at
### the center you don't have to check this again at this point
### this means that the below filter essentially filters for the maximum crosslinks
### at the center position
### NOTE do you mean the step befor or afterwards

###########################
# Keep only BS with max PureCLIP site at center
##########################
# get bw rles

### TODO MB
### Another import of merged bigwigs as RLE
### CHANGED MK

# split BS by strand
binding_sites_center_PS_plus <- binding_sites_center_PS[strand(binding_sites_center_PS)=="+"]
binding_sites_center_PS_minus <- binding_sites_center_PS[strand(binding_sites_center_PS)=="-"]

# make matrix of BS
binding_sites_center_PS_plus_m <- as.matrix(bw_plus_rle[binding_sites_center_PS_plus])
binding_sites_center_PS_minus_m <- as.matrix(bw_minus_rle[binding_sites_center_PS_minus])

# calculate max for each BS (one BS is one row in the matrix)
max_BS_plus <- apply(binding_sites_center_PS_plus_m,1,max)
max_BS_minus <- apply(binding_sites_center_PS_minus_m,1,max)

# subset for center = max
### TODO MB
### be aware that this is hard coded for a binding site width of 5
### a dynamic alternative would be `ceiling(windowsize/2)`
### CHANGED MK
binding_sites_center_PSmax_plus <- binding_sites_center_PS_plus[
  max_BS_plus == binding_sites_center_PS_plus_m[,((wbs-1)/2)]] 
binding_sites_center_PSmax_minus <- binding_sites_center_PS_minus[
  max_BS_minus == binding_sites_center_PS_minus_m[,((wbs-1)/2)]]



###########################
# Keep only BS with at least 2 crosslink sites
############################
binding_sites_center_PSmax_plus_m <- as.matrix(bw_plus_rle[binding_sites_center_PSmax_plus])
binding_sites_center_PSmax_minus_m <- as.matrix(bw_minus_rle[binding_sites_center_PSmax_minus])

### TODO MB
### be aware that this is hard coded for a binding site width of 5
### CHANGED MK
crosslink_sites_plus <- apply(binding_sites_center_PSmax_plus_m, 1, function(x) wbs-sum(x == 0)) 
crosslink_sites_minus <- apply(binding_sites_center_PSmax_minus_m, 1, function(x)wbs-sum(x == 0)) 


binding_sites_center_PSmax_plus_2cl <- binding_sites_center_PSmax_plus[crosslink_sites_plus > 1]
binding_sites_center_PSmax_minus_2cl <- binding_sites_center_PSmax_minus[crosslink_sites_minus > 1]

binding_sites_final <- c(binding_sites_center_PSmax_plus_2cl , binding_sites_center_PSmax_minus_2cl ) %>%
  keepStandardChromosomes(pruning.mode = "coarse")

```


# Sample reproducibility

```{r}
### TODO MB
### here where you actually use the replicate bigwig signal you re-import them 
### as RLE, which makes the GRanges import at the beginning not necessary. Also
### note that if you label an entire section for importing data one does not
### expect that there is an additional import of data at the bottom of the script.
### CHANGED MK


# sum up cl events per binding site 
bs.p = binding_sites_final[strand(binding_sites_final) == "+"]
bs.p$clp_rep1 = sample1.plus.rle[bs.p] %>% sum
bs.p$clp_rep2 = sample2.plus.rle[bs.p] %>% sum
bs.p$clp_rep3 = sample3.plus.rle[bs.p] %>% sum
bs.p$clp_rep4 = sample4.plus.rle[bs.p] %>% sum


bs.m = binding_sites_final[strand(binding_sites_final) == "-"]
bs.m$clp_rep1 = sample1.minus.rle[bs.m] %>% sum
bs.m$clp_rep2 = sample2.minus.rle[bs.m] %>% sum
bs.m$clp_rep3 = sample3.minus.rle[bs.m] %>% sum
bs.m$clp_rep4 = sample4.minus.rle[bs.m] %>% sum

# combine
binding_sites = c(bs.p, bs.m)


###########################################
# Overlap of binding sites between samples
###########################################

### TODO MB
### Here a binding site is considered reproducible by the replicate, if it has a
### single crosslink event overlapping from that replicate. Maybe be more 
### stringent here? See the dynamic replicate thresholding of BindingSiteFinder, 
### because library size varies between replicates
### NOTE MK
### did that before at some point we decided to be rather less stringent to fit oe data better, now we do  ot use oe data anymore but I don't want to change all again ...

binding_sites$names <-  1:length(binding_sites)
UpSet_List_cutoff20 = list(rep1 = binding_sites[binding_sites$clp_rep1> 0]$names,
                           rep2 = binding_sites[binding_sites$clp_rep2> 0]$names,
                           rep3 = binding_sites[binding_sites$clp_rep3> 0]$names,
                           rep4 = binding_sites[binding_sites$clp_rep4> 0]$names)

UpSetR::upset(UpSetR::fromList(UpSet_List_cutoff20), order.by = c("degree","freq"), nsets = 4)
grid.text("Overlap of binding sites between the 4 samples", x = 0.65, y=0.95, gp=gpar(fontsize=16))



#######################################################
# Scatterplot of crosslinks per binding site per sample
#######################################################
repro_df <- data.frame(s1 = binding_sites$clp_rep1,
                      s2 = binding_sites$clp_rep2,
                      s3 = binding_sites$clp_rep3,
                      s4 = binding_sites$clp_rep4) 

repro_scatter_df <- repro_df[,1:4] %>% mutate(s1 = log2(s1), s2 = log2(s2), s3=log2(s3), s4=log2(s4)) %>%
  mutate(s1 = case_when(s1== -Inf ~ 0, T ~ s1),
         s2 = case_when(s2== -Inf ~ 0, T ~ s2),
         s3 = case_when(s3== -Inf ~ 0, T ~ s3),
         s4 = case_when(s4== -Inf ~ 0, T ~ s4))

scatter_fn <- function(data, mapping, ...){
  p <- ggplot(data = data, mapping = mapping) + 
    ggrastr::rasterise( geom_point(), dpi = 300) +
    ggrastr::rasterise(stat_density2d(aes(fill=..level..), geom="polygon"), dpi = 300) +
    scale_fill_gradientn(colours=report_color) +
    coord_cartesian(xlim = c(0,12.5), ylim = c(0,12.5))+
    geom_abline(slope=1, colour = "darkgrey", linetype="dashed")
  p
}

cor_fun <- function(data, mapping, method="pearson", ndp=2, sz=3, stars=T, ...){
  
  x <- GGally::eval_data_col(data, mapping$x)
  y <- GGally::eval_data_col(data, mapping$y)
  
  corr <- cor.test(x, y, method=method)
  est <- corr$estimate
  lb.size <- sz* abs(est) 
  
  if(stars){
    stars <- c("***", "**", "*", "")[findInterval(corr$p.value, c(0, 0.001, 0.01, 0.05, 1))]
    lbl <- paste0(method, ": ", round(est, ndp), stars)
  }else{
    lbl <- round(est, ndp)
  }
  
  ggplot(data=data, mapping=mapping) + 
    annotate("text", label=lbl, x= 6, y= 6, size=lb.size,...)+
    theme(panel.grid = element_blank())
}


GGally::ggpairs(repro_scatter_df, upper = list(continuous = cor_fun), lower = list(continuous = scatter_fn), title = "Reproducability matrix - comparisons of 2 samples")+
  theme_bw()

```

# Output

- binding sites: binding_sites.rds

```{r eval=FALSE, include=FALSE}

# PURA binding sites
saveRDS(binding_sites, paste0("/Users/melinaklostermann/Documents/projects/PURA/Molitor-et-al-2022/", "binding_sites.rds"))

```
